#!/usr/bin/env zsh
# pipe-prompt - Interactive prompt for piping buffer contents through commands
#
# Usage: pipe-prompt <input_file> <output_file> <cmd_file>
#
# Arguments:
#   input_file  - File containing the input to pipe to the command
#   output_file - File where command output will be written
#   cmd_file    - File where the executed command will be recorded
#
# Features:
#   - Full ZLE support (history, Ctrl+R, tab completion, env vars)
#   - Vi keybindings with working reverse search
#   - On failure, shows error and re-prompts with command pre-filled
#   - Command is written to cmd_file for the calling process
#   - Exit status matches the executed command's exit status

if [[ $# -ne 3 ]]; then
    echo "Usage: pipe-prompt <input_file> <output_file> <cmd_file>" >&2
    exit 1
fi

input_file="$1"
output_file="$2"
cmd_file="$3"

# Verify input file exists
if [[ ! -r "$input_file" ]]; then
    echo "Error: Cannot read input file: $input_file" >&2
    exit 1
fi

# Enable vi mode
bindkey -v

cmd=""
while true; do
    # Prompt for command using vared (ZLE-based editing)
    # cmd retains previous value for editing on retry
    # -c positions cursor at end of pre-filled text so backspace works
    if ! vared -c ${#cmd} -p "pipe> " cmd; then
        # User pressed Ctrl+C or Ctrl+D
        exit 130
    fi

    # Handle empty command
    if [[ -z "$cmd" ]]; then
        exit 0
    fi

    # Execute command with input piped and output captured
    # stderr goes to terminal so user sees errors
    if eval "$cmd" < "$input_file" > "$output_file"; then
        # Success - write command and exit
        echo "$cmd" > "$cmd_file"
        exit 0
    fi

    # Command failed - loop to retry
    echo ""
done
